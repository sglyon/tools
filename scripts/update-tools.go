package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type Tool struct {
	Name        string
	Description string
	Path        string
}

func main() {
	fmt.Println("Updating tools list...")

	tools := findTools()
	if err := generateAppJS(tools); err != nil {
		fmt.Printf("Error generating app.js: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Tools list updated successfully!")
}

func findTools() []Tool {
	var tools []Tool

	entries, err := os.ReadDir(".")
	if err != nil {
		fmt.Printf("Error reading directory: %v\n", err)
		return tools
	}

	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}

		dirName := entry.Name()
		// Skip special directories
		if dirName == "scripts" || dirName == ".github" || strings.HasPrefix(dirName, ".") {
			continue
		}

		indexPath := filepath.Join(dirName, "index.html")
		if _, err := os.Stat(indexPath); os.IsNotExist(err) {
			continue
		}

		fmt.Println(entry.Name())
		tool := Tool{
			Name:        dirName,
			Description: "A useful web tool",
			Path:        dirName,
		}

		// Try to extract title and description from index.html
		content, err := os.ReadFile(indexPath)
		if err == nil {
			contentStr := string(content)

			// Extract title
			titleRe := regexp.MustCompile(`<title>([^<]+)</title>`)
			if matches := titleRe.FindStringSubmatch(contentStr); len(matches) > 1 {
				tool.Name = strings.TrimSpace(matches[1])
			}

			// Extract description from meta tag
			metaRe := regexp.MustCompile(`<meta\s+name="description"\s+content="([^"]+)"`)
			if matches := metaRe.FindStringSubmatch(contentStr); len(matches) > 1 {
				tool.Description = strings.TrimSpace(matches[1])
			} else {
				// Try to get first h2 or p tag content
				h2Re := regexp.MustCompile(`<h2[^>]*>([^<]+)</h2>`)
				pRe := regexp.MustCompile(`<p[^>]*>([^<]+)</p>`)

				if matches := h2Re.FindStringSubmatch(contentStr); len(matches) > 1 {
					desc := strings.TrimSpace(matches[1])
					if len(desc) > 100 {
						desc = desc[:100] + "..."
					}
					tool.Description = desc
				} else if matches := pRe.FindStringSubmatch(contentStr); len(matches) > 1 {
					desc := strings.TrimSpace(matches[1])
					if len(desc) > 100 {
						desc = desc[:100] + "..."
					}
					tool.Description = desc
				}
			}
		}

		tools = append(tools, tool)
	}

	return tools
}

func generateAppJS(tools []Tool) error {
	var jsContent strings.Builder

	jsContent.WriteString(`// This file will be automatically generated by the update script
const tools = [`)

	for i, tool := range tools {
		if i > 0 {
			jsContent.WriteString(",")
		}
		jsContent.WriteString(fmt.Sprintf(`
    {
        name: "%s",
        description: "%s",
        path: "%s"
    }`, escapeJS(tool.Name), escapeJS(tool.Description), escapeJS(tool.Path)))
	}

	jsContent.WriteString(`
];

function renderTools() {
    const toolsGrid = document.getElementById('tools-grid');

    if (tools.length === 0) {
        toolsGrid.innerHTML = '<p class="col-span-full text-center text-gray-500">No tools available yet. Check back soon!</p>';
        return;
    }

    toolsGrid.innerHTML = tools.map(tool => ` + "`" + `
        <a href="${tool.path}/" class="block bg-white border border-gray-200 rounded-lg p-6 hover:shadow-lg hover:-translate-y-0.5 transition-all duration-200">
            <h2 class="text-xl font-semibold text-blue-600 mb-2">${tool.name}</h2>
            <p class="text-gray-600">${tool.description}</p>
        </a>
    ` + "`" + `).join('');
}

document.addEventListener('DOMContentLoaded', renderTools);`)

	return os.WriteFile("app.js", []byte(jsContent.String()), 0644)
}

func escapeJS(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	s = strings.ReplaceAll(s, "\n", `\n`)
	s = strings.ReplaceAll(s, "\r", `\r`)
	s = strings.ReplaceAll(s, "\t", `\t`)
	return s
}
